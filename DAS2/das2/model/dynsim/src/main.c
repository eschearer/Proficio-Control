/*******************************************************************************

   MAIN.C

   Authors: Peter Loan
            Krystyne Blaikie

   Version 3.2.1, October 7, 2005

   Copyright (c) 1996-2005 MusculoGraphics, a division of Motion Analysis Corp.
   All rights reserved.

   Description: This file contains the main routine for a dynamics
		simulation, and several other utility functions that are
		independent of the musculoskeletal model in the simulation.
		This file is generated by SIMM when you choose the
		"project files" option in the "Save Dynamics" dialog box.
		You will probably want to generate it once (not every time you
      change your model) and then customize it to your specific simulation.

*******************************************************************************/
#include "universal.h"

/*************** DEFINES (for this file only) *********************************/

/* Tolerances and Integration parameters. */
#define BAUMGARTE_STAB 20.0

/*************** STATIC GLOBAL VARIABLES (for this file only) *****************/
SystemInfo si;

/**************** GLOBAL VARIABLES (used in only a few files) *****************/
dpModelStruct* sdm;
MotionData* kinetics_data = NULL;
dpSimulationParameters params;
char current_dir[CHARBUFFER];

/*************** EXTERNED VARIABLES (declared in another file) ****************/
extern char buffer[];
extern dpBoolean verbose;

/*************** PROTOTYPES for STATIC FUNCTIONS (for this file only) *********/
static void init_model(void);
void calc_force_vector(dpMuscleStruct* ms, double F[]);


main(void)
{
   int i, j, err, which, status, num_muscle_states,frame, scapula_num;
   int framenum,sdbody1,sdbody2,sdbody_help,dist_seg,num_dofs,num_cols,num_momarms,num_GH_mus,count;
   char **elementnames, **momarmnames, **GHfvectornames;
   double t, step, step_size, param[1] = {-1.0};
   double *y, *dy, *work, next_t;
   double start_time, end_time;
   double GHfvector[3]={0};
   double ke = 0, pe = 0;
   char *muscle_file = NULL, *kinetics_file = NULL;
   char *output_motion_file = NULL;
   char *output_kinetics_file = NULL;
   char *parameters_file_name = "params.txt";
   char e_msg[5000] = "";
   FILE *out, *kin_out, *lengthfile, *dofsfile, *momarmfile, *GHfile;
   dpMuscleStruct* ms;

   sim_message(none, "\nDynamics Pipeline (3.2.1) Simulation.\n");

   /* fill in sdm struct with model parameters */
   init_model();

   getcwd(current_dir, CHARBUFFER);
   append_if_necessary(current_dir, DIR_SEP_CHAR);

   get_muscle_file_name(parameters_file_name, &muscle_file);

   if (muscle_file)
   {
      if (read_muscle_file(sdm, muscle_file) == code_bad)
         sim_message(exit_program, "Error reading muscle file %s.", muscle_file);
   }
   else
   {
      sdm->num_muscles = 0;
      sim_message(none, "Running simulation without a muscle file.");
   }

   if (read_parameters_file(parameters_file_name, sdm, &kinetics_file,
      &output_motion_file, &output_kinetics_file) == code_bad)
   {
      sim_message(recover, "Unable to load input parameters: %s%s not found.\n", 
             current_dir, parameters_file_name);
   }

   init_joint_functions();
   init_q_restraint_functions();

   num_muscle_states = count_muscle_states(sdm);
   sdm->neq = sdm->nu + sdm->nq + num_muscle_states;

   y = (double*)simm_malloc(sdm->neq * sizeof(double));
   dy = (double*)simm_malloc(sdm->neq * sizeof(double));
   work = (double*)simm_malloc(6 * sdm->neq * sizeof(double));
	
   if (kinetics_file)
      set_up_kinetics_input(kinetics_file, &kinetics_data);

   set_initial_conditions(&t, y, dy);

   init_motion();

   sdinit();
   check_for_sderror("SDINIT");
	
   /* enable constraint stabilization */
   sdstab(2.0 * BAUMGARTE_STAB, BAUMGARTE_STAB * BAUMGARTE_STAB);

	if (sdm->newInverseSimulation == dpYes)
	{
		sdm->newInverseSimulation = dpNo;
		assemble_model(t, y);
		sdm->newInverseSimulation = dpYes;
	}
	else
	{
		assemble_model(t, y);
	}

   sdstate(t, y, &y[sdm->nq]);

   init_muscle_states(sdm, y);

   /***** write dofs.txt ********************************************/
   /* this includes the following information about each dof:       */
   /* name                                                          */ 
   /* distal segment                                                */
   /* upper and lower limits                                        */
   /*                                                               */
   /* it also includes the muscle names, and which dofs they cross  */
   /* syntax: <muscle name> <DOF1> <DOF2> ....                      */
   /* where in <DOF>: 1 if the muscle crosses it, 0 if it doesn't   */

   dofsfile = fopen("dofs.txt", "w");
   fprintf(dofsfile, "# for each dof:\n# name\n# distalsegment\n# lower and upper limits\n");

   // dofs
   fprintf(dofsfile, "dofs\n");

   // count actual dofs (not fixed)
   num_dofs=0;
   for (i = 0; i< sdm->nq; i++)
	   if (sdm->q[i].type != dpFixedQ)
		   num_dofs++;

   fprintf(dofsfile, "number_of_dofs %i\n",num_dofs);

   for (i = 0; i< sdm->nq; i++)
	   if (sdm->q[i].type != dpFixedQ)
	   {
		   fprintf(dofsfile,"%s\n",sdm->q[i].name); 
		   dist_seg = sdm->q[i].joint+1;
		   fprintf(dofsfile,"%s\n",sdm->body_segment[dist_seg].name); 
		   fprintf(dofsfile,"%f %f\n",sdm->q[i].range_start,sdm->q[i].range_end); 
   }

   fprintf(dofsfile, "enddofs\n\n");

   // momentarms
   fprintf(dofsfile, "# for each muscle:\n# name <dof1> <dof2> ...\n");
   fprintf(dofsfile, "# where: <dof> = 1 if the muscle crosses that dof, 0 if it doesn't\n");
   fprintf(dofsfile, "momentarms\n");

   // count the number of momentarms that are not zero
   // this is used in file momarms.mot
   num_momarms = 0;
   momarmnames = (char**)simm_calloc(sdm->num_muscles*sdm->nu, sizeof(char*));

   // count the number of muscles that cross GH
   // this is used in file GH_fvectors.mot
   num_GH_mus = 0;
   GHfvectornames = (char**)simm_calloc(sdm->num_muscles*3, sizeof(char*));

   for (i = 0; i < sdm->num_muscles; i++)
   {
	   if (sdm->muscles[i].output == dpYes)
	   {
		   ms = &(sdm->muscles[i]);
           fprintf(dofsfile, "%s ", sdm->muscles[i].name);

           sdbody1 = ms->mp[0]->segment;
           sdbody2 = ms->mp[ms->num_points - 1]->segment;

		   if (sdbody1>sdbody2)
		   {
				sdbody_help=sdbody1;
				sdbody1=sdbody2;
				sdbody2=sdbody_help;
		   }

           for (j = 0; j < sdm->nq; j++)
            {

			    // only include moment arms around DOFs the muscle crosses
                if ((sdm->q[j].output == dpYes)&&(sdm->q[j].joint>sdbody1)&&(sdm->q[j].joint<=sdbody2))
			   {
                  fprintf(dofsfile,"%i ",1);

				  // write the name of this moment arm in a string
				  // this is used in file momarms.mot
                  sprintf(buffer, "%s_ma_%s", ms->name, sdm->q[j].name);
                  mstrcpy(&momarmnames[num_momarms], buffer);

				  num_momarms++;

				  // check if it crosses GH
			      if (STRINGS_ARE_EQUAL(sdm->q[j].name,"GH_y"))
				  {
					// write the name of this muscle force vector in a string
					// this is used in file GH_fvectors.mot
					sprintf(buffer, "%s_GH_force_x", ms->name);
					mstrcpy(&GHfvectornames[3*num_GH_mus], buffer);
					sprintf(buffer, "%s_GH_force_y", ms->name);
					mstrcpy(&GHfvectornames[3*num_GH_mus+1], buffer);
					sprintf(buffer, "%s_GH_force_z", ms->name);
					mstrcpy(&GHfvectornames[3*num_GH_mus+2], buffer);
					num_GH_mus++;
				  }

			   }
			   else if (sdm->q[j].output == dpYes)
				   fprintf(dofsfile,"%i ",0);
            }
			fprintf(dofsfile,"\n");
	   }
   }

   fprintf(dofsfile, "endmomentarms\n");
   fclose(dofsfile);


	// set dofs to zero for calculation of musculotendon lenghts
	for (i=7;i<12;i++)
		y[i]=0;


   /***** write zerolength.txt ****************************************/
   /* this includes the musculotendon length when all dofs are zero   */
   /* syntax: <muscle name> <length at zero position>                 */

	lengthfile = fopen("zerolength.txt", "w");
	fprintf(lengthfile,"%s\n","# musculotendon length when all DOFs are zero");
	for (i = 0; i < sdm->num_muscles; i++)
	{
		ms = &sdm->muscles[i];
		fprintf(lengthfile, "%s %10.5f\n", ms->name, calc_muscle_tendon_length(ms));
	}
	fclose(lengthfile);

    /******************************************************************/

	sim_message(none, "\nSystem assembled (%d bodies, %d Qs, %d Us, %d muscles, %d muscle states).\n",
      sdm->num_body_segments, sdm->nq, sdm->nu, sdm->num_muscles, num_muscle_states);

   sim_message(none, "Running simulation from time %lf to %lf (step size = %lf).\n",
               params.startTime, params.endTime, params.stepSize);


   si.initial_system_energy = MINMDOUBLE;

   /**** write momarms.mot ***************************************************/
   /* this has the header of a SIMM motion file                              */
   /* and includes the time, dofs and moment arms for every time step        */

   momarmfile = fopen("momarms.mot", "w");

   // number of frames
   framenum = (params.endTime - params.startTime) / params.stepSize + 1.99999;

   // number of columns: time, number of dofs, and number of momentarms that are not zero
   num_cols = 1 + num_dofs + num_momarms;

   // header
   fprintf(momarmfile, "name %s\ndatacolumns %d\n", "momarm.mot", num_cols);
   fprintf(momarmfile, "datarows %d\n", framenum);
   fprintf(momarmfile, "range %lf %lf\n", params.startTime, params.endTime);
   fprintf(momarmfile, "cursor 1.0 1.0 0.0\n");
   fprintf(momarmfile, "keys m_key\n");
   fprintf(momarmfile, "wrap\n");
   fprintf(momarmfile, "enforce_loops no\n");
   fprintf(momarmfile, "enforce_constraints no\n");
   fprintf(momarmfile, "calc_derivatives %lf\n", params.stepSize);
   fprintf(momarmfile, "endheader\n\n");

   // now write line with names of elements: time, dofs and momentarms that are not zero
   elementnames = (char**)simm_calloc(num_cols, sizeof(char*));
   count = 0;

   // time
   mstrcpy(&elementnames[count++], "time");

   // dofs
   for (i = 0; i< sdm->nq; i++)
	   if (sdm->q[i].type != dpFixedQ)
	   {
		   sprintf(buffer, "%s_gcv", sdm->q[i].name);
		   mstrcpy(&elementnames[count++], buffer);
	   }

	// moment arms : already stored in string momarmnames
   for (i=0;i<num_momarms;i++)
	   mstrcpy(&elementnames[count++], momarmnames[i]);

   for (i = 0; i < num_cols; i++)
      fprintf(momarmfile, "%s\t", elementnames[i]);

   fprintf(momarmfile, "\n");
   // end header

   free(momarmnames);
   free(elementnames);

   /**** write GH_fvectors.mot ***********************************************/
   /* this has the header of a SIMM motion file                              */
   /* and includes the time, dofs and GH force vectors for every time step   */

   GHfile = fopen("GH_fvectors.mot", "w");

   // number of frames
   framenum = (params.endTime - params.startTime) / params.stepSize + 1.99999;

   // number of columns: time, number of dofs, and number of momentarms that are not zero
   num_cols = 1 + num_dofs + 3*num_GH_mus;

   // header
   fprintf(GHfile, "name %s\ndatacolumns %d\n", "GH_fvectors.mot", num_cols);
   fprintf(GHfile, "datarows %d\n", framenum);
   fprintf(GHfile, "range %lf %lf\n", params.startTime, params.endTime);
   fprintf(GHfile, "cursor 1.0 1.0 0.0\n");
   fprintf(GHfile, "keys m_key\n");
   fprintf(GHfile, "wrap\n");
   fprintf(GHfile, "enforce_loops no\n");
   fprintf(GHfile, "enforce_constraints no\n");
   fprintf(GHfile, "calc_derivatives %lf\n", params.stepSize);
   fprintf(GHfile, "endheader\n\n");

   // now write line with names of elements: time, dofs and fvectors for muscles that cross GH
   elementnames = (char**)simm_calloc(num_cols, sizeof(char*));
   count = 0;

   // time
   mstrcpy(&elementnames[count++], "time");

   // dofs
   for (i = 0; i< sdm->nq; i++)
	   if (sdm->q[i].type != dpFixedQ)
	   {
		   sprintf(buffer, "%s_gcv", sdm->q[i].name);
		   mstrcpy(&elementnames[count++], buffer);
	   }

	// GH fvectors : already stored in string GHfvectornames
   for (i=0;i<3*num_GH_mus;i++)
	   mstrcpy(&elementnames[count++], GHfvectornames[i]);

   for (i = 0; i < num_cols; i++)
      fprintf(GHfile, "%s\t", elementnames[i]);

   fprintf(GHfile, "\n");
   // end header

   free(GHfvectornames);
   free(elementnames);

   /***** main loop ****************************************************/

    frame=0;
	for (t = params.startTime; t < params.endTime - TINY_TIME; )
    {
		step = step_size = params.stepSize;
		next_t = t + step_size;
      if (next_t > params.endTime)
      {
         next_t = params.endTime;
         step = step_size = next_t - t;
      }

	  // assign the dof values for the new timestep to the state vector
	  for (i=7;i<12;i++)
		  y[i]=kinetics_data->motiondata[i-6][frame]/sdm->q[i].conversion;

      assign_muscle_states(sdm, t, y);

      // For each muscle, calculate correct wrapping
      for (i = 0; i < sdm->num_muscles; i++)
	  {
         ms = &sdm->muscles[i];
		 check_wrapping_points(ms, y);
	  }

      // calculate moment arms 
      calc_muscle_moment_arms(t, y);

	 // write time and dofs in momarms.mot and GH_fvectors.mot
	 // time 
     fprintf(momarmfile, "%5.10lf\t", t);
     fprintf(GHfile, "%5.10lf\t", t);
	
	 /* Write Qs */
     for (i = 0; i< sdm->nq; i++)
	      if (sdm->q[i].type != dpFixedQ)
		  {
			  fprintf(momarmfile, "%5.10lf\t", y[i] * sdm->q[i].conversion);
			  fprintf(GHfile, "%5.10lf\t", y[i] * sdm->q[i].conversion);
		  }

     /* write muscle moment arms in momarms.mot */
	 for (i = 0; i < sdm->num_muscles; i++)
	 {
         if (sdm->muscles[i].output == dpYes)
         {
			ms = &(sdm->muscles[i]);

            sdbody1 = ms->mp[0]->segment;
            sdbody2 = ms->mp[ms->num_points - 1]->segment;

			if (sdbody1>sdbody2)
			{
				sdbody_help=sdbody1;
				sdbody1=sdbody2;
				sdbody2=sdbody_help;
			}

			// only include moment arms around DOFs the muscle crosses
            for (j = 0; j < sdm->nq; j++)
               if ((sdm->q[j].type != dpFixedQ)&&(sdm->q[j].joint>sdbody1)&&(sdm->q[j].joint<=sdbody2))
                  fprintf(momarmfile, "%5.10lf\t", ms->momentarms[j]);
         }
      }
      fprintf(momarmfile, "\n");

	  // find which body segment number corresponds to scapula_r
	  for (i=0;i<sdm->num_body_segments;i++)
			if (STRINGS_ARE_EQUAL(sdm->body_segment[i].name,"scapula_r")) 
				scapula_num=i-1; // in sdfast, ground is -1

	  /* calculate and write muscle GH force vectors in GH_fvectors.mot */
	 for (i = 0; i < sdm->num_muscles; i++)
	 {
         if (sdm->muscles[i].output == dpYes)
         {
			ms = &(sdm->muscles[i]);

            sdbody1 = ms->mp[0]->segment;
            sdbody2 = ms->mp[ms->num_points - 1]->segment;

			if (sdbody1>sdbody2)
			{
				sdbody_help=sdbody1;
				sdbody1=sdbody2;
				sdbody2=sdbody_help;
			}

			// only include muscles that cross GH
            for (j = 0; j < sdm->nq; j++)
               if ((sdm->q[j].type != dpFixedQ)&&(sdm->q[j].joint>sdbody1)&&(sdm->q[j].joint<=sdbody2)&&(STRINGS_ARE_EQUAL(sdm->q[j].name,"GH_y")))
			   {
				  calc_force_vector(ms, GHfvector, scapula_num);
                  fprintf(GHfile, "%5.10lf\t", GHfvector[0]);
                  fprintf(GHfile, "%5.10lf\t", GHfvector[1]);
                  fprintf(GHfile, "%5.10lf\t", GHfvector[2]);
			   }
         }
      }
      fprintf(GHfile, "\n");

      printf("time = %.8lf\r", t);

	  t = next_t;
	  frame++;
	}

	/***********************************************************************/

END_SIMULATION:
   sim_message(none, "\n*** SIMULATION ENDED ***");

   fclose(momarmfile);
   fclose(GHfile);

   free(work);
   free(y);
   free(dy);

   sim_message(none, "\nPress Enter to continue.");
   getc(stdin);

}


static void init_model(void)
{

   int i, info[50];

   params.startTime = 0.0;
   params.endTime = 1.0;
   params.stepSize = 0.01;
   params.outputOptions.contactForces = dpYes;
   params.outputOptions.jointTorques = dpNo;
   params.outputOptions.jointReactionForces = dpNo;
   params.outputOptions.jointReactionTorques = dpNo;
   params.outputOptions.massCenterPositions = dpNo;
   params.outputOptions.massCenterVelocities = dpNo;
   params.outputOptions.muscleMomentArms = dpNo;
   params.outputOptions.muscleJointTorques = dpNo;
	params.outputOptions.traditionalInverse = dpYes;
   params.outputOptions.totalMuscleJointTorques = dpNo;
   params.outputOptions.optimizedMuscleActivations = dpNo;
   params.outputOptions.muscleActivations = dpYes;
   params.outputOptions.muscleLengths = dpNo;
   params.outputOptions.muscleFiberLengths = dpNo;
   params.outputOptions.muscleFiberVelocities = dpNo;
   params.outputOptions.muscleForces = dpYes;
   params.outputOptions.systemEnergy = dpNo;
   params.outputOptions.numSpringForces = 20;
   params.outputOptions.normalization = dpNoNormalization;
	params.outputOptions.gencoordValues = dpYes;

   sdinfo(info);
   sdm = (dpModelStruct*)simm_malloc(sizeof(dpModelStruct));
   sdm->num_body_segments = info[1] + 1;    /* include ground */
   sdm->nq = info[2] + info[7];
   sdm->nu = info[2];
   sdm->num_closed_loops = info[4];
   sdm->num_joints = info[1] + info[4]; /* nbod + nloop */
   sdm->num_constraints = info[3];
   sdm->num_user_constraints = info[10];
   sdm->num_springs = 0;
   sdm->num_spring_floors = 0;
   sdm->num_force_mattes = 0;
   sdm->spring_array_size = ARRAY_INCREMENT;
   sdm->spring_floor_array_size = ARRAY_INCREMENT;
   sdm->force_matte_array_size = ARRAY_INCREMENT;
   sdm->enforce_constraints = dpYes;
	sdm->newInverseSimulation = dpNo;

   init_qs();
   init_segments();
   init_joints();
   init_wrap_objects();
   init_constraint_objects();

#if CONTACT_DETECTION
   makepaths();

   for (i = 0; i < sdm->num_body_segments; i++)
   {
      sdm->body_segment[i].num_objects = 0;
      make_vector(sdm->body_segment[i].impact_force, 0.0, 0.0, 0.0);
      make_vector(sdm->body_segment[i].impact_point, 0.0, 0.0, 0.0);
      make_vector(sdm->body_segment[i].contact_force, 0.0, 0.0, 0.0);
   }
#endif
}


/* SIM_MESSAGE: this function prints an error message depending on the string
 * and error status that is passed in. There is a separate version of
 * this function for the DLL version of a simulation.
 */
int sim_message(ErrorAction action, const char* format, ...)
{
   int n;
   char c;
   va_list ap;
   char buffer3[CHARBUFFER];

   va_start(ap, format);
   n = vsprintf(buffer3, format, ap);
   va_end(ap);

   (void)fprintf(stdout,"%s\n", buffer3);

   if (action == recover)
   {
      (void)fprintf(stdout,"Do you want to continue? (y/n)<y>:  ");
      c = getc(stdin);
      if ((c == 'n') || (c == 'N'))
      {
         (void)fprintf(stdout, "Program terminated.\n");
         getc(stdin);
         exit(0);
      }
      else
      {
         (void)fprintf(stdout, "Continuing...\n");
         fflush(stdin);
      }
   }
   else if (action == abort_action)
   {
      (void)fprintf(stdout, "Aborting...\n");
   }
   else if (action == exit_program)
   {
      (void)fprintf(stdout, "Program terminated.\n");
      getc(stdin);
      exit (0);
   }

   return n;

}

void calc_force_vector(dpMuscleStruct* ms, double n_body_force_vector[], int scapula_num)
{

    int i, sdbody1, sdbody2, start, stop;
    double force_vector[3], body_force_vector[3];
    double inertial_pt1[3], inertial_pt2[3];

	// calculate GH_fvectors for glenoid constaint
		for (start = 0;start<ms->num_points-1;start++)
		{
			stop = start + 1;

			sdbody1 = ms->mp[start]->segment;
			sdbody2 = ms->mp[stop]->segment;


		   // calculate force on the scapula from the humerus or forearm
			// ...whether scapula is the first of the two segments
			if ((sdbody1<=scapula_num)&&(sdbody2>scapula_num))
			{
	    	// Calculate direction of force in the ground (inertial) reference frame 
				sdpos(sdbody1, ms->mp[start]->point, inertial_pt1);
				sdpos(sdbody2, ms->mp[stop]->point, inertial_pt2);
				for (i = 0; i < 3; i++)
					force_vector[i] = inertial_pt1[i] - inertial_pt2[i];

	     		// Transform the vector into the scapular coordinate frame
				sdtrans(GROUND, force_vector, scapula_num, body_force_vector);
				normalize_vector(body_force_vector, n_body_force_vector);
				break;
			}

			// ...or the second
			else if ((sdbody2<=scapula_num)&&(sdbody1>scapula_num))
			{
	    	// Calculate direction of force in the ground (inertial) reference frame 
				sdpos(sdbody1, ms->mp[start]->point, inertial_pt1);
				sdpos(sdbody2, ms->mp[stop]->point, inertial_pt2);
				for (i = 0; i < 3; i++)
					force_vector[i] = inertial_pt2[i] - inertial_pt1[i];

	     		// Transform the vector into the scapular coordinate frame
				sdtrans(GROUND, force_vector, scapula_num, body_force_vector);
				normalize_vector(body_force_vector, n_body_force_vector);
				break;
			}
	 }

}