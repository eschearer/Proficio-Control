function error = pathpo_GH(path, modelname)

% pathpo_GH.m
%
% Computes best fitting polynomial for GH muscle force vectors as a function
% of kinematic degrees of freedom q.
%
% This is done from GH force vectors generated by SIMM
%
% Dimitra Blana - 5/29/07
% Based on pathpoly.m by Ton van den Bogert
%
% notes:
% - writes all polynomials to one file (poly_results_GH.txt)
% - all force vectors are read from one SIMM motion file into matrix
%   GHfvectors

%% setup directories and open files

format long;			% so we get full precision output for polynomial coefficients

% this is where GHpoly.cfg is
% and where data files for this model will be stored
folder = [path modelname '/model'];

% config file (input)
fullpath = [folder '/GHpoly.cfg'];
configfile = fopen(fullpath,'r');
if (configfile < 0)
    fprintf('Error: could not open %s\n', fullpath);
    fclose('all');
    error = 1;
    return;
end

% log file (output)
fullpath = [folder '/GHpoly.log'];
logfile = fopen(fullpath,'w');
if (logfile < 0)
    fprintf('Error: could not open %s\n', fullpath);
    fclose('all');
    error = 1;
    return;
end

% results file (output)
fullpath = [folder '/poly_results_GH.txt'];
polyfile = fopen(fullpath,'w');
if (polyfile < 0)
    fprintf('Error: could not open %s\n', fullpath);
    fclose('all');
    error = 1;
    return;
end

%% get GH force vectors out of SIMM motion file
% SIMM motion file where moment arms are stored
% this is written on the fourth line of the config file
d=0;
while d==0
    fgets(configfile);
    s = fgets(configfile);
    d = sscanf(s,'%d');
    % this is 1 if the muscle crosses GH, 0 if it doesn't
end
fgets(configfile);
filename = fgetl(configfile);
fseek(configfile, 0, 'bof'); % reposition the file identifier to the beginning of the config file

fullpath = [folder '/' filename];
fvectorfile = fopen(fullpath,'r');
if (fvectorfile < 0)
    fprintf('Error: could not open %s\n', fullpath);
    fclose('all');
    error = 1;
    return;
end

% get number of columns from the line: 'datacolumns <>'
line = fgetl(fvectorfile);
while (not(strncmp(line, 'datacolumns', 11)))
    line = fgetl(fvectorfile);
end
num_col = sscanf(line, '%*s%i');

% skip rest of header: look for keyword 'endheader' and skip 2 more lines after that
line = fgetl(fvectorfile);
while (not(strcmp(line, 'endheader')))
    line = fgetl(fvectorfile);
end
fgetl(fvectorfile); % empty line after end of header
fgetl(fvectorfile); % line with names of DOFs and fvectors

% put all the fvector data in matrix GHfvector
GHfvector = fscanf(fvectorfile,'%f',[num_col,inf]); % it reads in column order
GHfvector = GHfvector';
num_data = size(GHfvector,1);
fclose(fvectorfile);

forcedir = ['x','y','z'];
%% main loop for each muscle element
while 1
    % read next muscle name from config file
    musclename = fgets(configfile);        
    s = fgets(configfile);
    if s<=0, break, end		% quit if end of config file is reached
    musclename = strtrim(musclename);
    d = sscanf(s,'%d');
    % this is 1 if the muscle crosses GH, 0 if it doesn't
    if ~d
        continue;
    end
    s = fgets(configfile);
    d = sscanf(s,'%d');
    % read number of dofs spanned by this muscle, and which polynomial order requested
    ndofs = d(1,1);
    order = d(2,1);

    % count how many parameters the polynomial model for GH fvector has
    npar = prod(1:ndofs+order)/prod(1:ndofs)/prod(1:order);
    fprintf(1,'Muscle name:      %s\n',musclename);
    fprintf(1,'Number of DOFs:   %d\n',ndofs);
    fprintf(1,'Polynomial order: %d\n',order);
    fprintf(1,'Potential number of polynomial terms: %d\n',npar);

    fprintf(polyfile,musclename);
    fprintf(polyfile,'\n');

    % GH fvector data for this muscle come from ndofs files, with names
    % listed in the config file
    for i = 1:3  % three components of the fvector (x-y-z)
        A = zeros(num_data, npar);	% allocate memory space for A
         % read from config file the filename and column numbers where data can be found
        fgetl(configfile);  % this is not used here anymore (see comment in start of file)
        s = fgetl(configfile);
        if s<=0, break, end		% quit if end of config.txt is reached
        r = sscanf(s,'%d');
        mcol = r(1);
        acol = r(2:ndofs+1);

        % read data from GHfvector matrix
        % take fvector and angles from the right columns
        b = GHfvector(:,mcol);
        ang = (GHfvector(:,acol) + 1e-6) * pi/180;	% convert to radians and protect against angle = 0.0

        % generate the npar polynomial terms, and for each term, add a column to A
        polylist = zeros(npar,ndofs);
        expon = zeros(num_data,ndofs);	% start with all exponents zero
        for ii=1:npar
            polylist(ii,:) = expon(1,:);
            A(:,ii) = prod(ang.^expon,2); % contribution of this term to force component i
            % generate the next set of exponents, but remain within model order
            k = 1;
            while (1)
                expon(:,k) = expon(:,k)+1;
                if (sum(expon(1,:)) > order && ii<npar)
                    expon(:,k)=0;
                    k = k+1;
                else
                    break;
                end
            end
        end     % done generating model terms
        fprintf('Total number of data points: %d\n',num_data);
        
        vecrange = abs(max(b)-min(b));
        
        % now we have all data for this muscle stored in A and b
        % solve the full model with npar terms
        p = A\b;		% compute coefficients of the best fitting model

        bpred = A*p;	% these are the force vectors predicted by this model
        res = bpred-b;	% residuals
        RMSfull = (sqrt(sum(res.^2)/num_data));		% RMS of (normalized) residuals
        fprintf('RMS fit error of the full model is: %f (normalized)\n',RMSfull);
        fprintf('min amplitude: %f\n',min(b));
        fprintf('max amplitude: %f\n',max(b));
        fprintf('range of amplitudes: %f\n',vecrange);
        fprintf(logfile,'%s\n',musclename);
        fprintf(logfile,'  RMS fit error of the full model is: %f (normalized)\n',RMSfull);
        fprintf(logfile,'range of amplitudes: %f\n',vecrange);

        % now do stepwise regression to select polynomial terms for a smaller model
        Aselected = [];
        polylist_selected = [];
        npar_selected = 0;
        % outer loop: successively add columns to Aselected
        for ii = 1:npar-1
            [nrows, ncolumns] = size(A);
            % inner loop: find the column of A that causes most reduction in RMS when added to Aselected
            RMSnew = zeros(1,ncolumns); % this will store the RMS errors of each expanded model
            for j = 1:ncolumns
                % add column j from A to Anew
                Anew = [Aselected A(:,j)];
                % solve new p's
                pnew = Anew\b;
                % compute new RMS fit error
                RMSnew(j) = (norm(Anew*pnew - b)/(sqrt(num_data))); 
            end
            % now determine which expanded model had the lowest RMS
            [RMSmin, col] = min(RMSnew);
            % if the change in error is less than 5%, stop without adding this term 
            if ((ii>1)&&((RMS - RMSmin)/RMS<0.05))
                fprintf('Change in error: %3f. No more terms added.\n ',(RMS - RMSmin)/RMS);
                fprintf(logfile,'Change in error: %3f. No more terms added.\n ',(RMS - RMSmin)/RMS);
                break;
            end
            % otherwise add this column to Aselected
            Aselected = [Aselected A(:,col)];npar_selected = npar_selected + 1;
            p = Aselected\b;		% solve the coefficients (again)
            % compute some error measures
            SSE = sum((Aselected*p-b).^2); 			% summed squared errors (SSE)
            RMS = (sqrt(SSE/num_data)); 			% RMS error, is the same as what we had before
            
            GCV = SSE/((num_data - npar_selected)^2);    	% Generalized Cross Validation
            AIC = log(SSE) + 2*npar_selected/num_data;   	% Akaike's Information Criterion
            % print what we just did, on screen and on output file
            fprintf('Model addition step %3i: Added term ',ii);
            fprintf('%i ',polylist(col,:));
            fprintf('-- RMS=%6.2f, GCV=%8.3e, AIC = %6.2f\n',RMS,GCV,AIC);
            fprintf(logfile,'  Model addition step %3i: Added term ',ii);
            fprintf(logfile,'%i ',polylist(col,:));
            fprintf(logfile,'-- RMS=%f, GCV=%e, AIC = %f\n',RMS,GCV,AIC);

            % remember the exponents of this polynomial term
            polylist_selected = [polylist_selected ; polylist(col,:)];
            % remove this column from A and from polylist so it is not used again
            A = [A(:,1:(col-1)) A(:,(col+1):ncolumns)];
            polylist = [polylist(1:(col-1),:);polylist((col+1):ncolumns,:)];           
            % stop adding terms if RMS error in fvectors is less than 10% of range, 
            if (RMS<=0.1*vecrange)
                break;
            end
        end 		% and go find the next term

        % write this muscle's model on the output file
        fprintf(polyfile,'parameters %d\n',npar_selected);
        fprintf(polyfile,'# exponents ... coefficient for %c force\n',forcedir(i));
        for ii = 1:npar_selected
            fprintf(polyfile,'\t');
            fprintf(polyfile,'%3d ',polylist_selected(ii,:));
            fprintf(polyfile,'   %10.5e \n', p(ii));
        end
        fprintf(logfile,'  %d polynomial terms were written for %s %c force\n',npar_selected, musclename,forcedir(i));
        fprintf('  %d polynomial terms were written for %s %c force\n',npar_selected, musclename,forcedir(i));
    end		% done reading all data files for this muscle
end 		% go process next muscle

fclose(configfile);
fclose(polyfile);
fclose(logfile);
error = 0;